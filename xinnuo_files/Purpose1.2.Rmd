---
title: "REU0605"
author: "Xinnuo Chen"
date: "2025-06-01"
output: html_document
---

```{r}
library(ggplot2)
library(mvtnorm)
library(synthpop)
library(NbClust)
library(factoextra)
library(DescTools)    # Gini
library(cluster)      # Silhouette
library(car)          # scatterplot
library(tidyverse)
library(clue)         # label switching
library(rpart)
library(dgof)
library(dplyr)
library(tibble)
library(paletteer)
library(scales)
library(tidyr)        # pivot_longer
library(mvtnorm)
library(parallel)
library(pbapply)
library(patchwork)

synt.data.generation <- function(real.data, m, methods){
    syn.obj <- syn(real.data,
                       method = rep(methods, ncol(real.data)),
                       m = m,
                       print.flag = FALSE, 
                       proper = TRUE)
    synt.data <- syn.obj$syn
    specks.val <- numeric()
    if(m==1){
      names(synt.data) <- names(real.data)
      data <- rbind(
            cbind(real.data, label = 0),
            cbind(synt.data, label = 1)
          )
      specks.val <- c(specks.val, specks.correct(data = data)$Specks)
      specks.value <- data.frame(SPECKS = specks.val)
    } else {
      for(k in 1:m){
          names(synt.data[[k]]) <- names(real.data)
          
          data <- rbind(
            cbind(real.data, label = 0),
            cbind(synt.data[[k]], label = 1)
          )
          
          specks.val <- c(specks.val, specks.correct(data = data)$Specks)
          specks.value <- data.frame(SPECKS = specks.val)
      }
    }
    results <- list("Specks" = specks.value, "Syn data" = synt.data)
    return(results)
}


label.switching <- function(km.real, km.synt){ # Label switching function
  if(!is.null(km.synt)){
      centroids <- rbind(km.real$centers, km.synt$centers)
      dist.global <- as.matrix(dist(centroids, method = "euclidean"))
      n.real <- nrow(km.real$centers) #numero de cluster en real
      n.synt <- nrow(km.synt$centers) #numero de cluster en synt
      dist <- dist.global[1:n.real, (n.real + 1) : (n.real + n.synt)]
      label.ass <- solve_LSAP(dist, maximum = FALSE) 
      
      # Reetiquetació els clústers sintètics
      km.synt$recluster <- km.real$cluster # nova variable
      
      for (i in 1:length(label.ass)) {
        km.synt$recluster[km.synt$cluster == label.ass[i]] <- i
      }
  }
  return(km.synt)
}

centroid.generation <- function(k = k, p = p, separation = separation) {
  centroids <- matrix(NA, nrow = k, ncol = p)
  centroids[1, ] <- rep(0, p)                 # primer centroide a l'origen 
  for (i in 2:k) {
    tries <- 0
    repeat {
      vector <- rnorm(p)                      # un punt aleatori
      vector <- vector / sqrt(sum(vector^2))  # normalitzar el vector del punt
      vector <- vector * separation           # punt a distància separation de l’origen
      
      dists <- sqrt(rowSums((centroids[1:(i - 1), , drop = FALSE] -  # distàncies del nou punt amb cada un dels ja fixats.
                             matrix(vector, nrow = i - 1, ncol = p, byrow = TRUE))^2))
      if (all(dists >= separation)) {         # si el nou punt compleix la separació s'accepta
        centroids[i, ] <- vector
        break
      }
      tries <- tries + 1                      # evitar bucle infinit
      if (tries > 1000) stop("No s'han pogut generar centroides prou separats.")
    }
  }
  return(centroids)
}

data.generation <- function(N, p, rho, separation, k){
  # posició dels centroides
  centroids <- centroid.generation(k = k, p = p, separation = separation)
  
  # matriu de correlacions
  R <- matrix(rho, nrow = p, ncol = p)
  diag(R) <- 1
  
  # matriu de covariàncies
  sd <- rep(1, p)
  D <- diag(sd)
  Sigma <- D %*% R %*% D  #
  
  # generació de dades per cada cluster
  n <- round(N/k, digits = 0)
  clusters <- lapply(1:k, function(i) {
    rmvnorm(n,
            mean  = centroids[i, ],
            sigma = Sigma)
  })
  data <- do.call(rbind, clusters)
  data <- data.frame(data, group = factor(rep(1:k, each = n)))
  
  # representació gràfica
  Graphic <- ggplot(data, aes(x = X1, y = X2, color = group)) +
                geom_point(size = 2) +
                scale_color_brewer(palette = "Set1") +
                labs(
                  title = "First dimention representation",
                  color = "Cluster"
                ) +
                theme_minimal(base_size = 14)
  result <- list("Data" = data[,-ncol(data)], "Graphic"=Graphic, "Clusters" = clusters)
}

specks.correct <- function(data, sample=FALSE){   #### With pvalue
  if(sample==TRUE){
    data[,3] <- sample(data[,3])
  }
  
  N <- nrow(data)
  idx <- sample(1:N, round(N*0.3, digits=0))
  
  data.train <- data[-idx,]
  data.test <- data[idx,]
  
  logit_model <- glm(label ~ ., data = data.train, family = "binomial")
  
  pred.prob <- predict(logit_model, newdata = data.test, type = "response")
  
  label.vector <- data.test$label
  
  prop.score.real  <- pred.prob[label.vector == 0]
  prop.score.synt  <- pred.prob[label.vector == 1]
  
  ecdf.real  <- ecdf(prop.score.real)
  ecdf.synth <- ecdf(prop.score.synt)
  
  all.scores <- sort(unique(c(prop.score.real, prop.score.synt)))
  
  specks.value <- max(abs(ecdf.real(all.scores) - ecdf.synth(all.scores)))
  p.value <- suppressWarnings(ks.test(prop.score.real, prop.score.synt)$p)
  
  return(data.frame(
    "Specks" = specks.value, 
    "P-value" = p.value))
}

k.decision <- function(data, k.real = 0, synthetic = TRUE){ # K decision & clustering 
  if(synthetic == FALSE){
    sil <- fviz_nbclust(data, kmeans, method = "silhouette")$data
    kopt <- as.numeric(sil$clusters[which.max(sil$y)])
    
    sdata <- scale(data)
    clust <- kmeans(sdata, kopt, nstart = 25)
    
    clustering.result <- list("K optim" = kopt, "Clustering" = clust)
    return(clustering.result)
  } else {
    sil <- fviz_nbclust(data, kmeans, method = "silhouette")$data
    kopt <- as.numeric(sil$clusters[which.max(sil$y)])
    
    if(kopt == k.real){
      sdata <- scale(data)
      clust <- kmeans(sdata, kopt, nstart = 25) #resultado de clustering
      
      clustering.result <- list("K optim" = kopt, "Clustering" = clust)
      return(clustering.result)
    }
  }
}
```


# Content:
-   Graph of clusters superimposed by different separation between cluster centroids.
-   Gini for unbalanced cluster

# (1). Graph of clusters superimposed by different scenarios of separation between centroids.

```{r}
set.seed(12)
rdata <- data.generation(250, p = 2, rho = 0, separation = 10, k = 2)

real.data <- rdata$Data
rdata$Graphic

sdata <- synt.data.generation(real.data, m = 1, method = "cart")
synt.data <- sdata$`Syn data`

real.wss <- fviz_nbclust(real.data, kmeans, method="silhouette")$data
real.k <- as.numeric(real.wss$clusters[which.max(real.wss$y)])

synt.wss <- fviz_nbclust(synt.data, kmeans, method="silhouette")$data
synt.k <- as.numeric(synt.wss$clusters[which.max(synt.wss$y)])
real.k
synt.k

# Clustering
real.km <- kmeans(real.data, real.k, nstart = 25)
synt.km <- kmeans(synt.data, synt.k, nstart = 25)
synt.km <- label.switching(real.km, synt.km)
synt.km$cluster <- synt.km$recluster

real.col <- "#3182bd"
synt.col <- "#e6550d"

real.clust <- fviz_cluster(real.km, data = real.data,
               geom  = "point",
               palette = rep(real.col, nrow(real.km$centers)),
               ellipse.type = "euclid",
               stand        = FALSE,
               star.plot = TRUE, 
               ggtheme = theme_minimal())

synt.clust <- fviz_cluster(synt.km, data = synt.data,
               geom  = "point",
               palette = rep(synt.col, nrow(synt.km$centers)),
               ellipse.type = "euclid",
               stand        = FALSE,
               star.plot = TRUE, 
               ggtheme = theme_minimal())

real.clust
synt.clust
```


## Superimposed graphics
```{r}
df.all <- bind_rows(
  real.data %>% mutate(set = "Real",
                       cluster = factor(real.km$cluster)),
  synt.data %>% mutate(set = "Synt",
                       cluster = factor(synt.km$cluster))
)

centres  <- df.all %>%
  group_by(set, cluster) %>%
  summarise(cx = mean(X1), cy = mean(X2), .groups = "drop")

segments <- df.all %>% left_join(centres, by = c("set", "cluster"))

real.col <- "#3182bd"   # real set color
synt.col <- "#e6550d"   # synthetic set color

# Superimposed graphics
cluter.graph <- ggplot() +
  geom_segment(data = segments, # line
               aes(x = X1, y = X2, xend = cx, yend = cy,
                   colour = set),
               linewidth = .3, alpha = .55) +

  geom_point(data = df.all, # point
             aes(X1, X2, colour = set, shape = cluster),
             size = .5) +

  stat_ellipse(data  = df.all,
               aes(X1, X2,
                   group  = interaction(set, cluster),
                   colour = set),
               type  = "euclid",
               level = 1,
               linewidth = 1,
               alpha = .25) +

  scale_colour_manual(values = c(Real = real.col, Synt = synt.col),
                      name = "Data type") +
  scale_fill_manual(values   = c(Real = alpha(real.col, .25),
                                 Synt = alpha(synt.col, .25)),
                    guide = "none") +
  scale_shape_manual(values = c(`1` = 16, `2` = 17, `3` = 15, `4` = 3)) +

  labs(title = "Real vs Synthetic clusters",
       x = "X1", y = "X2",
       shape = "Cluster group") +
  theme_minimal(base_size = 13)

cluter.graph
```


## Function for superimposed graphics generation
```{r}
separation <- c(2, 6, 10)
k <- c(2, 3, 4)

plots <- list()                     # store the plots in a list
max_try <- 100

for(i in separation){
  for(j in k){
    ntry <- 0
    repeat{
      set.seed(ntry)
      rdata <- data.generation(250, p = 2, rho = 0, separation = i, k = j)
      real.data <- rdata$Data
      
      sdata <- synt.data.generation(real.data, m = 1, method = "cart")
      synt.data <- sdata$`Syn data`
      
      real.wss <- fviz_nbclust(real.data, kmeans, method="silhouette")$data
      real.k <- as.numeric(real.wss$clusters[which.max(real.wss$y)])
      
      synt.wss <- fviz_nbclust(synt.data, kmeans, method="silhouette")$data
      synt.k <- as.numeric(synt.wss$clusters[which.max(synt.wss$y)])
      
      if( (real.k == synt.k) && (real.k == j) ) break
      
      ntry <- ntry + 1             # attempt control
      if (ntry >= max_try) {
        warning(sprintf("sep=%s, k=%s: no match after % attempts.",
                        i, j, max_try))
        break
      }
    }
    
    if (real.k != synt.k) next
    
    # clustering
    real.km <- kmeans(real.data, real.k, nstart = 25)
    synt.km <- kmeans(synt.data, synt.k, nstart = 25)
    synt.km <- label.switching(real.km, synt.km)
    synt.km$cluster <- synt.km$recluster
    
    # graphic
    df.all <- bind_rows(
      real.data %>% mutate(set = "Real",
                           cluster = factor(real.km$cluster)),
      synt.data %>% mutate(set = "Synt",
                           cluster = factor(synt.km$cluster))
    )
      
    centres  <- df.all %>%
      group_by(set, cluster) %>%
      summarise(cx = mean(X1), cy = mean(X2), .groups = "drop")
    
    segments <- df.all %>% left_join(centres, by = c("set", "cluster"))
    
    # graphic colour
    real.col <- "#3182bd"
    synt.col <- "#e6550d"
      
    gname <- sprintf("sep%s_k%s", i, j)
      
    # superimposed graphic
    p <- ggplot() +
      geom_segment(data = segments, # line
                   aes(x = X1, y = X2, xend = cx, yend = cy,
                       colour = set),
                   linewidth = .3, alpha = .55) +
      
      geom_point(data = df.all, # point
                 aes(X1, X2, colour = set, shape = cluster),
                 size = .5) +
      
      stat_ellipse(data  = df.all, #
                   aes(X1, X2,
                       group  = interaction(set, cluster),
                       colour = set),
                   type  = "euclid",
                   level = 1,
                   linewidth = 1,
                   alpha = .25) +
      scale_colour_manual(values = c(Real = real.col, Synt = synt.col),
                          name = "Data type") +
      scale_fill_manual(values   = c(Real = alpha(real.col, .25),
                                     Synt = alpha(synt.col, .25)),
                        guide = "none") +
      scale_shape_manual(values = c(`1` = 16, `2` = 17, `3` = 15, `4` = 3)) +
      
      labs(title = sprintf("%sSD separation & %s cluster", i, j),
           x = "X1", y = "X2",
           shape = "Cluster group") +
      theme_minimal(base_size = 13)
      
    ggsave(filename = paste0("plot_", gname, ".png"),
           plot     = p,
           width    = 4, height = 3, dpi = 300)

    plots[[gname]] <- p
  }
}

plots

layout <- ((plots[["sep2_k2"]]  | plots[["sep2_k3"]]  | plots[["sep2_k4"]]) /
            (plots[["sep6_k2"]]  | plots[["sep6_k3"]]  | plots[["sep6_k4"]] ) /
            (plots[["sep10_k2"]] | plots[["sep10_k3"]] | plots[["sep10_k4"]] ))


print(layout)

ggsave(
  filename = "Real_VS_Synthetic.png",
  plot     = layout,
  width    = 27, 
  height   = 15,
  dpi      = 300
)
```


## Equalise graph scale
```{r}
set.seed(12345)
separation <- c(2, 6, 10)
k <- c(2, 3, 4)

plots <- list()
max_try <- 100
data.list <- list()

for(i in separation){
  for(j in k){
    ntry <- 0
    repeat{
      set.seed(ntry)
      rdata <- data.generation(250, p = 2, rho = 0, separation = i, k = j)
      real.data <- rdata$Data

      sdata <- synt.data.generation(real.data, m = 1, method = "cart")
      synt.data <- sdata$`Syn data`

      real.wss <- fviz_nbclust(real.data, kmeans, method="silhouette")$data
      real.k <- as.numeric(real.wss$clusters[which.max(real.wss$y)])

      synt.wss <- fviz_nbclust(synt.data, kmeans, method="silhouette")$data
      synt.k <- as.numeric(synt.wss$clusters[which.max(synt.wss$y)])

      if( (real.k == synt.k) && (real.k == j) ) break

      ntry <- ntry + 1
      if (ntry >= max_try) {
        warning(sprintf("sep=%s, k=%s: no match after %d attempts.", i, j, max_try))
        break
      }
    }

    # Skip if conditions not met (either no match found or max tries reached)
    if ((real.k != synt.k) || (real.k != j)) next

    real.km <- kmeans(real.data, real.k, nstart = 25)
    synt.km <- kmeans(synt.data, synt.k, nstart = 25)
    synt.km <- label.switching(real.km, synt.km)
    synt.km$cluster <- synt.km$recluster

    df.all <- bind_rows(
      real.data %>% mutate(set = "Real", cluster = factor(real.km$cluster)),
      synt.data %>% mutate(set = "Synt", cluster = factor(synt.km$cluster))
    )

    gname <- sprintf("sep%s_k%s", i, j)
    data.list[[gname]] <- list(data = df.all, title = sprintf("%sSD separation & %s cluster", i, j))

    # Uncaled individual graphs
    centres <- df.all %>%
      group_by(set, cluster) %>%
      summarise(cx = mean(X1), cy = mean(X2), .groups = "drop")

    segments <- df.all %>% left_join(centres, by = c("set", "cluster"))

    real.col <- "#3182bd"
    synt.col <- "#e6550d"

    p <- ggplot() +
      geom_segment(data = segments,
                   aes(x = X1, y = X2, xend = cx, yend = cy,
                       colour = set),
                   linewidth = .3, alpha = .55) +
      geom_point(data = df.all,
                 aes(X1, X2, colour = set, shape = cluster),
                 size = .5) +
      stat_ellipse(data  = df.all,
                   aes(X1, X2,
                       group  = interaction(set, cluster),
                       colour = set),
                   type = "euclid",
                   level = 1,
                   linewidth = 1,
                   alpha = .25) +
      scale_colour_manual(values = c(Real = real.col, Synt = synt.col),
                          name = "Data type") +
      scale_fill_manual(values = c(Real = alpha(real.col, .25),
                                   Synt = alpha(synt.col, .25)),
                        guide = "none") +
      scale_shape_manual(values = c(`1` = 16, `2` = 17, `3` = 15, `4` = 3)) +
      labs(title = sprintf("%sSD separation & %s cluster", i, j),
           x = "X1", y = "X2",
           shape = "Cluster group") +
      theme_minimal(base_size = 13)

    plots[[gname]] <- p
  }
}

required_layout <- c("sep2_k2", "sep2_k3", "sep2_k4",
                     "sep6_k2", "sep6_k3", "sep6_k4",
                     "sep10_k2", "sep10_k3", "sep10_k4")
missing_layout <- setdiff(required_layout, names(plots))

if(length(missing_layout) == 0){
  layout_original <- (plots[["sep2_k2"]] | plots[["sep2_k3"]] | plots[["sep2_k4"]]) /
                     (plots[["sep6_k2"]] | plots[["sep6_k3"]] | plots[["sep6_k4"]]) /
                     (plots[["sep10_k2"]] | plots[["sep10_k3"]] | plots[["sep10_k4"]])
  ggsave(
    filename = "Real_VS_Synthetic.png",
    plot     = layout_original,
    width    = 27,
    height   = 15,
    dpi      = 300
  )
} else {
  message("Skipping full layout; missing plots: ", paste(missing_layout, collapse = ", "))
}


# Extrem graphics rescaled
selected_names <- c("sep2_k2", "sep2_k4", "sep6_k2", "sep10_k4")
missing_rescaled <- setdiff(selected_names, names(plots))

if(length(missing_rescaled) == 0){
  x_range <- c(Inf, -Inf)
  y_range <- c(Inf, -Inf)

  for(gname in selected_names) {
    df <- data.list[[gname]]$data
    x_range[1] <- min(x_range[1], min(df$X1))
    x_range[2] <- max(x_range[2], max(df$X1))
    y_range[1] <- min(y_range[1], min(df$X2))
    y_range[2] <- max(y_range[2], max(df$X2))
  }

  plots_rescaled <- list()

  for(gname in selected_names) {
    df.all <- data.list[[gname]]$data
    title  <- data.list[[gname]]$title

    centres <- df.all %>%
      group_by(set, cluster) %>%
      summarise(cx = mean(X1), cy = mean(X2), .groups = "drop")

    segments <- df.all %>% left_join(centres, by = c("set", "cluster"))

    real.col <- "#3182bd"
    synt.col <- "#e6550d"

    p <- ggplot() +
      geom_segment(data = segments,
                   aes(x = X1, y = X2, xend = cx, yend = cy,
                       colour = set),
                   linewidth = .3, alpha = .55) +
      geom_point(data = df.all,
                 aes(X1, X2, colour = set, shape = cluster),
                 size = .5) +
      stat_ellipse(data  = df.all,
                   aes(X1, X2,
                       group  = interaction(set, cluster),
                       colour = set),
                   type = "euclid",
                   level = 1,
                   linewidth = 1,
                   alpha = .25) +
      scale_colour_manual(values = c(Real = real.col, Synt = synt.col),
                          name = "Data type") +
      scale_fill_manual(values = c(Real = alpha(real.col, .25),
                                   Synt = alpha(synt.col, .25)),
                        guide = "none") +
      scale_shape_manual(values = c(`1` = 16, `2` = 17, `3` = 15, `4` = 3)) +
      labs(title = title,
           x = "X1", y = "X2",
           shape = "Cluster group") +
      coord_cartesian(xlim = x_range, ylim = y_range) +
      theme_minimal(base_size = 13)

    plots_rescaled[[gname]] <- p
  }

  layout_rescaled <- (plots_rescaled[["sep2_k2"]] | plots_rescaled[["sep2_k4"]]) /
                     (plots_rescaled[["sep6_k2"]] | plots_rescaled[["sep10_k4"]]) 

  ggsave(
    filename = "Real_VS_Synthetic_scaled.png",
    plot     = layout_rescaled,
    width    = 27,
    height   = 15,
    dpi      = 300
  )
} else {
  message("Skipping rescaled layout; missing plots: ", paste(missing_rescaled, collapse = ", "))
}
```


# (2). Factors reanalysis

## All metrics
```{r}
simulate_one <- function(factor.combination, max_attempts = 200L, verbose = TRUE) # Calcul function for each combination
{
  N <- factor.combination$N
  p <- factor.combination$p
  k <- factor.combination$k
  rho <- factor.combination$rho
  method <- factor.combination$method
  separation <- factor.combination$separation
  total.m <- total.m
  
  kd <- NULL
  k.real <- NA_integer_
  km.real <- NULL
  found_real <- FALSE
  
  for(attempt in seq_len(max_attempts)) {
    set.seed(attempt)
    real.data <- data.generation(N, p, rho, separation, k)$Data
    kd <- k.decision(real.data, synthetic = FALSE)
    k.real <- kd$`K optim`
    if(k.real == k) {
      km.real <- kd$Clustering
      found_real <- TRUE
      break
    }
  }
  
  if(!found_real) {
    if(verbose) {
      warning(sprintf("simulate_one: Max attempts (%d) reached without matching k=%s for N=%s, p=%s, separation=%s.",
                      max_attempts, k, N, p, separation))
    }
    return(NULL)
  }
  
  vars <- names(real.data)
  
  gini.real <- Gini(km.real$size)
  sil.real <- mean(silhouette(km.real$cluster, dist(real.data))[,3])
    
  lreal.data <- real.data
  lreal.data$label <- as.factor(km.real$cluster)
  
  out <- data.frame()
  
  # Synthetic data generation - FIXED ITERATION APPROACH
  n_simulations <- total.m
  successes <- 0
  
  synt.data <- list()
  km.synt <- list()
  k.synt <- numeric()
  speck <- numeric()
  successful_indices <- integer()
  
  for (i in 1:n_simulations) {
    set.seed(i)
    syn   <- synt.data.generation(real.data, m = 1, methods = method)
    clust <- k.decision(syn$`Syn data`, k.real = k.real)
    
    if(!is.null(clust)){
      successes <- successes + 1
      successful_indices <- c(successful_indices, i)
      synt.data[[successes]] <- syn$`Syn data`
      km.synt[[successes]] <- clust$Clustering
      k.synt[successes] <- clust$`K optim`
      speck[successes] <- syn$Specks$SPECKS
    }
  }
  
  # Store the proportion of successful matches
  success_rate <- successes / n_simulations
  
  if (successes == 0) {
    # If no successful matches, return a minimal result with 0% success
    out <- data.frame(N = N,
                     p = p,
                     k = k,
                     rho = rho,
                     method = method,
                     separation = separation,
                     k.real = k.real,
                     Speck = NA,
                     success_rate = 0,
                     Gini.real = gini.real,
                     Gini.synt = NA,
                     Sil.real = sil.real,
                     Sil.synt = NA,
                     Mean.distance = NA,
                     Mean.var = NA)
    return(out)
  }
  
  m <- successes
  
  ls.km.synt <- lapply(km.synt, label.switching, km.real) # Synthetic data after label switching
  
  # Metrics
  
  ## Gini
  gini.syn <- sapply(km.synt, function(km) Gini(km$size))
  
  sil.synt <- numeric(m)      
  mean.distance <- numeric(m)
  mean.var <- numeric(m)
  for (i in seq_along(km.synt)){
    lsynt.data <- synt.data[[i]]
    lsynt.data$label <- factor(ls.km.synt[[i]]$recluster)
    
    ## Silhouette
    sil.synt[i] <- mean(silhouette(km.synt[[i]]$cluster, dist(synt.data[[i]]))[,3])
    
    ## Mean distance between centroids 
    real.centroid <- aggregate(. ~ label,
                                data = lreal.data[, c(vars, "label")],
                                FUN = base::mean)
    synt.centroid <- aggregate(. ~ label,
                                data = lsynt.data[, c(vars, "label")],
                                FUN = base::mean)
    real.centroid <- real.centroid[order(real.centroid$label), ]
    synt.centroid <- synt.centroid[order(synt.centroid$label), ]
        
    mat.real <- as.matrix(real.centroid[, vars])
    mat.synt <- as.matrix(synt.centroid[, vars])
    distances <- sqrt(rowSums((mat.real - mat.synt)^2))
    mean.distance[i] <- mean(distances)
    
    ## Mean variance between centroids 
    real.var <- aggregate(. ~ label,
                          data = lreal.data[, c(vars, "label")],
                          FUN = var)
    synt.var <- aggregate(. ~ label,
                          data = lsynt.data[, c(vars, "label")],
                          FUN = var)
    real.var <- real.var[order(real.var$label), ]
    synt.var <- synt.var[order(synt.var$label), ]
    
    mat.real.var <- as.matrix(real.var[, vars])
    mat.synt.var <- as.matrix(synt.var[, vars])
    
    dif.var <- abs(mat.real.var - mat.synt.var)
    mean.var[i] <- mean(dif.var)
  }      
  out <- rbind(out,
    data.frame(N = rep(N, m),
               p = rep(p, m),
               k = rep(k, m),
               rho = rep(rho, m),
               method = rep(method, m),
               separation = rep(separation, m),
               k.real = rep(k.real, m),
               Speck = speck,
               success_rate = rep(success_rate, m),
               Gini.real = rep(gini.real, m),
               Gini.synt = gini.syn,
               Sil.real = rep(sil.real, m),
               Sil.synt = sil.synt,
               Mean.distance = mean.distance,
               Mean.var = mean.var))
  return(out)
}


n.cores <- detectCores() - 1
cl <- makeCluster(n.cores)
total.m <- 50


clusterEvalQ(cl, {
  library(mvtnorm)
  library(NbClust)
  library(synthpop)
  library(clue)
  library(DescTools)
  library(factoextra)
  library(cluster)
})


clusterExport(cl, # functions
  varlist = c("simulate_one",
              "data.generation",
              "centroid.generation",
              "synt.data.generation",
              "k.decision",
              "label.switching",
              "specks.correct",
              "total.m"),
  envir = .GlobalEnv)


clusterSetRNGStream(cl, iseed = 123)
pboptions(type = "timer")

method <- c("norm")
N <- c(50)
p <- c(2, 5)
rho <- c(0)
k <- c(2, 3)
separation <- c(0.1, 2, 10)

param.grid <- expand.grid(N = N, # all possible combinations
                          p = p,
                          k = k,
                          rho = rho,
                          method = method,
                          separation = separation,
                          KEEP.OUT.ATTRS = FALSE)


result.list <- pblapply(
  X   = split(param.grid, seq_len(nrow(param.grid))),
  cl  = cl,
  FUN = simulate_one
)

result.list <- Filter(Negate(is.null), result.list)
if (!length(result.list)) {
  stop("simulate_one returned no successful results for the specified grid.")
}
result_norm_50_allmetrics <- dplyr::bind_rows(result.list)

stopCluster(cl)

```



```{r}
if(!exists("result_cart_50_allmetrics")){
  n.cores <- detectCores() - 1
  cl <- makeCluster(n.cores)
  total.m <- 50
  
  clusterEvalQ(cl, {
    library(mvtnorm)
    library(NbClust)
    library(synthpop)
    library(clue)
    library(DescTools)
    library(factoextra)
    library(cluster)
  })
  
  clusterExport(cl,
    varlist = c("simulate_one",
                "data.generation",
                "centroid.generation",
                "synt.data.generation",
                "k.decision",
                "label.switching",
                "specks.correct",
                "total.m"),
    envir = .GlobalEnv)
  
  clusterSetRNGStream(cl, iseed = 123)
  pboptions(type = "timer")
  
  method <- c("cart")
  N <- c(50)
  p <- c(2, 5)
  rho <- c(0)
  k <- c(2, 3)
  separation <- c(2, 10)
  
  param.grid <- expand.grid(N = N,
                            p = p,
                            k = k,
                            rho = rho,
                            method = method,
                            separation = separation,
                            KEEP.OUT.ATTRS = FALSE)
  
  result.list <- pblapply(
    X   = split(param.grid, seq_len(nrow(param.grid))),
    cl  = cl,
    FUN = simulate_one
  )
  
  result.list <- Filter(Negate(is.null), result.list)
  if (!length(result.list)) {
    stop("simulate_one returned no successful results for the specified grid.")
  }
  result_cart_50_allmetrics <- dplyr::bind_rows(result.list)
  stopCluster(cl)
}



## Univariante analysis
#### Separation

result <- result_cart_50_allmetrics

result <- result %>%
  mutate(Diff.gini = Gini.real - Gini.synt) %>%
  mutate(Diff.sil = Sil.real - Sil.synt)

distance <- result %>%
  mutate(separation = factor(separation,
                             levels = sort(unique(separation)),
                             labels = paste0(sort(unique(separation)), "σ")))

# Diff.gini
distance.gini <- ggplot(distance, aes(x = separation, y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Diff.gini"
  ) +
  theme_minimal(base_size = 14)

# Diff.sil
distance.sil <- ggplot(distance, aes(x = separation, y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Diff.sil"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
distance.mean <- ggplot(distance, aes(x = separation, y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Mean.distance"
  ) +
  theme_minimal(base_size = 14)

# Mean.var
distance.var <- ggplot(distance, aes(x = separation, y = Mean.var)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Mean.var"
  ) +
  theme_minimal(base_size = 14)

# Specks
distance.speck <- ggplot(distance, aes(x = separation, y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Specks"
  ) +
  theme_minimal(base_size = 14)


print(distance.gini)
print(distance.sil)
print(distance.mean)
print(distance.var)
print(distance.speck)


#### Cluster

clusternum <- result %>%
  mutate(separation = factor(k,
                             levels = sort(unique(k)),
                             labels = sort(unique(k))))

# Diff.gini
clusternum.gini <- ggplot(clusternum, aes(x = factor(k), y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

# Diff.sil
clusternum.sil <- ggplot(clusternum, aes(x = factor(k), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
clusternum.mean <- ggplot(clusternum, aes(x = factor(k), y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

# Mean.var
clusternum.var <- ggplot(clusternum, aes(x = factor(k), y = Mean.var)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

# Specks
clusternum.speck <- ggplot(clusternum, aes(x = factor(k), y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster",
    y     = "Specks"
  ) +
  theme_minimal(base_size = 14)


print(clusternum.gini)
print(clusternum.sil)
print(clusternum.mean)
print(clusternum.var)
print(clusternum.speck)


#### p
variable <- result %>%
  mutate(separation = factor(p,
                             levels = sort(unique(p)),
                             labels = sort(unique(p))))

# Diff.gini
variable.gini <- ggplot(variable, aes(x = factor(p), y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# Diff.sil
variable.sil <- ggplot(variable, aes(x = factor(p), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
variable.mean <- ggplot(variable, aes(x = factor(p), y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# Mean.var
variable.var <- ggplot(variable, aes(x = factor(p), y = Mean.var)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# Specks
variable.speck <- ggplot(variable, aes(x = factor(p), y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables",
    y     = "Specks"
  ) +
  theme_minimal(base_size = 14)


print(variable.gini)
print(variable.sil)
print(variable.mean)
print(variable.var)
print(variable.speck)


#### Correlation
correlation <- result %>%
  mutate(separation = factor(rho,
                             levels = sort(unique(rho)),
                             labels = sort(unique(rho))))

# Diff.gini
correlation.gini <- ggplot(correlation, aes(x = factor(rho), y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Correlation"
  ) +
  theme_minimal(base_size = 14)

# Diff.sil
correlation.sil <- ggplot(correlation, aes(x = factor(rho), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Correlation"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
correlation.mean <- ggplot(correlation, aes(x = factor(rho), y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Correlation"
  ) +
  theme_minimal(base_size = 14)

# Mean.var
correlation.var <- ggplot(correlation, aes(x = factor(rho), y = Mean.var)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Correlation"
  ) +
  theme_minimal(base_size = 14)

# Specks
correlation.speck <- ggplot(correlation, aes(x = factor(rho), y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Correlation",
    y     = "Specks"
  ) +
  theme_minimal(base_size = 14)

print(correlation.gini)
print(correlation.sil)
print(correlation.mean)
print(correlation.var)
print(correlation.speck)




### Graphic matriz

layout.metric <- ((distance.gini  | clusternum.gini  | variable.gini  | correlation.gini) /
                  (distance.sil  | clusternum.sil  | variable.sil  | correlation.sil) /
                  (distance.mean  | clusternum.mean  | variable.mean  | correlation.mean) /
                  (distance.var  | clusternum.var  | variable.var  | correlation.var))

layout.speck <- ( (distance.speck  | clusternum.speck  | variable.speck) ) 

print(layout)

ggsave(
  filename = "specks_vs_factors.png",
  plot     = layout,
  width    = 12,
  height   = 6,
  dpi      = 300
)


### Method comparison

# Ensure both datasets have the same column structure
if("count" %in% names(result_norm_50_allmetrics) && !"success_rate" %in% names(result_norm_50_allmetrics)) {
  result_norm_50_allmetrics <- result_norm_50_allmetrics %>%
    mutate(success_rate = 50 / count) %>%
    select(-count)
}
if("count" %in% names(result_cart_50_allmetrics) && !"success_rate" %in% names(result_cart_50_allmetrics)) {
  result_cart_50_allmetrics <- result_cart_50_allmetrics %>%
    mutate(success_rate = 50 / count) %>%
    select(-count)
}

result <- rbind(result_norm_50_allmetrics, result_cart_50_allmetrics)

result <- result %>%
  mutate(Diff.gini = Gini.real - Gini.synt) %>%
  mutate(Diff.sil = Sil.real - Sil.synt)


methodgen <- result %>%
  mutate(separation = factor(method,
                             levels = sort(unique(method)),
                             labels = sort(unique(method))))

# Diff.gini
method.gini <- ggplot(methodgen, aes(x = method, y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Method",
    y     = "Diff.gini"
  ) +
  theme_minimal(base_size = 14)

# Diff.sil
method.sil <- ggplot(methodgen, aes(x = method, y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Method",
    y     = "Diff.sil"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
method.mean <- ggplot(methodgen, aes(x = method, y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Method",
    y     = "Mean.distance"
  ) +
  theme_minimal(base_size = 14)

# Mean.var
method.var <- ggplot(methodgen, aes(x = method, y = Mean.var)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Method",
    y     = "Mean.var"
  ) +
  theme_minimal(base_size = 14)

layout <- ( (method.gini | method.sil | method.mean | method.var) )
print(layout)

ggsave(
  filename = "clustering_summary_method.png",
  plot     = layout,
  width    = 12, 
  height   = 6,
  dpi      = 300
)

### Sil according to method


# cart
result <- result_cart_50_allmetrics

result <- result %>%
  mutate(Diff.gini = Gini.real - Gini.synt) %>%
  mutate(Diff.sil = Sil.real - Sil.synt)


distance <- result %>%
  mutate(separation = factor(separation,
                             levels = sort(unique(separation)),
                             labels = paste0(sort(unique(separation)), "σ")))
distance.sil.cart <- ggplot(distance, aes(x = separation, y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Diff.sil"
  ) +
  theme_minimal(base_size = 14)

clusternum <- result %>%
  mutate(separation = factor(k,
                             levels = sort(unique(k)),
                             labels = sort(unique(k))))
clusternum.sil.cart <- ggplot(clusternum, aes(x = factor(k), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

variable <- result %>%
  mutate(separation = factor(p,
                             levels = sort(unique(p)),
                             labels = sort(unique(p))))
variable.sil.cart <- ggplot(variable, aes(x = factor(p), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# norm
result <- result_norm_50_allmetrics

result <- result %>%
  mutate(Diff.gini = Gini.real - Gini.synt) %>%
  mutate(Diff.sil = Sil.real - Sil.synt)


distance <- result %>%
  mutate(separation = factor(separation,
                             levels = sort(unique(separation)),
                             labels = paste0(sort(unique(separation)), "σ")))
distance.sil.norm <- ggplot(distance, aes(x = separation, y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Diff.sil"
  ) +
  theme_minimal(base_size = 14)

clusternum <- result %>%
  mutate(separation = factor(k,
                             levels = sort(unique(k)),
                             labels = sort(unique(k))))
clusternum.sil.norm <- ggplot(clusternum, aes(x = factor(k), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

variable <- result %>%
  mutate(separation = factor(p,
                             levels = sort(unique(p)),
                             labels = sort(unique(p))))
variable.sil.norm <- ggplot(variable, aes(x = factor(p), y = Diff.sil)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# graphic 
row_title_norm <- ggplot() + 
  annotate("text", x = 0, y = 0, label = "norm", angle = 90, size = 7) +
  theme_void()

row_title_cart <- ggplot() + 
  annotate("text", x = 0, y = 0, label = "cart", angle = 90, size = 7) +
  theme_void()

layout <- (
  (row_title_norm | distance.sil.norm | clusternum.sil.norm | variable.sil.norm) /
  (row_title_cart | distance.sil.cart  | clusternum.sil.cart  | variable.sil.cart)
) 

print(layout)

# ggsave(
#   filename = "clustering_method_gini.png",
#   plot     = layout,
#   width    = 12, 
#   height   = 5, 
#   dpi      = 300 
# )



data.generation.nobalance <- function(N, p, rho, separation, k){
  # Centroid positions
  centroids <- centroid.generation(k = k, p = p, separation = separation)
  
  # Correlation matrix
  R <- matrix(rho, nrow = p, ncol = p)
  diag(R) <- 1
  
  # Covariance matrix
  sd <- rep(1, p)
  D <- diag(sd)
  Sigma <- D %*% R %*% D  # covariance = D * R * D
  
  # Data generation for each cluster
  prop <- switch(as.character(k),
                 `2` = c(.4, .6),
                 `3` = c(.3, .4, .3),
                 `4` = c(.2, .4, .15, .25))  # unbalanced proportions
  n <- round(prop * N, digits = 0)
  
  # Adjustment if rounding error causes total N mismatch
  diff <- N - sum(n)
  if(diff != 0) n[which.min(n)] <- n[which.min(n)] + diff
  
  clusters <- lapply(1:k, function(i) {
    rmvnorm(n[i],
            mean  = centroids[i, ],
            sigma = Sigma)
  })
  data <- do.call(rbind, clusters)
  data <- data.frame(data, group = factor(rep(1:k, times = n)))
  
  # Graphical representation of the first two dimensions
  Graphic <- ggplot(data, aes(x = X1, y = X2, color = group)) +
    geom_point(size = 2) +
    scale_color_brewer(palette = "Set1") +
    labs(
      title = "First dimension representation",
      color = "Cluster"
    ) +
    theme_minimal(base_size = 14)
  
  result <- list("Data" = data[ , -ncol(data)], "Graphic" = Graphic, "Clusters" = clusters)
}

simulate_unbalanced <- function(factor.combination)
{
  N <- factor.combination$N
  p <- factor.combination$p
  k <- factor.combination$k
  rho <- factor.combination$rho
  method <- factor.combination$method
  separation <- factor.combination$separation
  total.m <- total.m
  
  count <- 0
  repeat{
    set.seed(count)
    real.data <- data.generation.nobalance(N, p, rho, separation, k)$Data # data generation function for unbalanced groups
  
    kd        <- k.decision(real.data, synthetic = FALSE)
    k.real    <- kd$`K optim`
    if(k.real == k) break
    
    count <- count + 1
    if(count >= total.m){
      warning("No combination of data with %k number of clusters found")
    }
  }
  
  km.real   <- kd$Clustering
  vars <- names(real.data)
  
  gini.real <- Gini(km.real$size)
  
  lreal.data <- real.data
  lreal.data$label <- as.factor(km.real$cluster)
  
  out <- data.frame()
  
  # Synthetic data generation
  count <- 0
  m <- 0
  synt.data <- list()
  km.synt <- list()
  k.synt <- numeric()
  speck <- numeric()
  while(m <= total.m){
    set.seed(m + count)
    count <- count + 1
    syn   <- synt.data.generation(real.data, m = 1, methods = method)
    clust <- k.decision(syn$`Syn data`, k.real = k.real)
    if(!is.null(clust)){
      m <- m + 1
      synt.data[[m]] <- syn$`Syn data`
      km.synt[[m]] <- clust$Clustering
      k.synt[m] <- clust$`K optim`
      speck[m] <- syn$Specks$SPECKS
    }
  }
  
  ls.km.synt <- lapply(km.synt, label.switching, km.real) #synthetic data after label switching
  
  # Metrics
  gini.syn <- sapply(km.synt, function(km) Gini(km$size))
        
  mean.distance <- numeric(m)
  for (i in seq_along(km.synt)){
    lsynt.data <- synt.data[[i]]
    lsynt.data$label <- factor(ls.km.synt[[i]]$recluster)
    real.centroid <- aggregate(. ~ label,
                                data = lreal.data[, c(vars, "label")],
                                FUN = base::mean)
    synt.centroid <- aggregate(. ~ label,
                                data = lsynt.data[, c(vars, "label")],
                                FUN = base::mean)
    real.centroid <- real.centroid[order(real.centroid$label), ]
    synt.centroid <- synt.centroid[order(synt.centroid$label), ]
        
    mat.real <- as.matrix(real.centroid[, vars])
    mat.synt <- as.matrix(synt.centroid[, vars])
    distances <- sqrt(rowSums((mat.real - mat.synt)^2))
    mean.distance[i] <- mean(distances)
  }      
  out <- rbind(out,
    data.frame(N = rep(N, m),
               p = rep(p, m),
               k = rep(k, m),
               rho = rep(rho, m),
               method = rep(method, m),
               separation = rep(separation, m),
               k.real = rep(k.real, m),
               Speck = speck,
               count = rep(count, m),
               Gini.real = rep(gini.real, m),
               Gini.synt = gini.syn,
               Mean.distance = mean.distance))
  return(out)
}


n.cores <- detectCores() - 1
cl <- makeCluster(n.cores)
total.m <- 50


clusterEvalQ(cl, {
  library(mvtnorm)
  library(NbClust)
  library(synthpop)
  library(clue)
  library(DescTools)
  library(factoextra)
})


clusterExport(cl, # functions
  varlist = c("simulate_unbalanced",
              "data.generation.nobalance",
              "centroid.generation",
              "synt.data.generation",
              "k.decision",
              "label.switching",
              "specks.correct",
              "total.m"),
  envir = .GlobalEnv)


clusterSetRNGStream(cl, iseed = 123)

method <- c("cart")
N <- c(250)
p <- c(2,5)
rho <- c(0)
k <- c(2, 3, 4)
separation <- c(2, 10)

param.grid <- expand.grid(N = N,
                          p = p,
                          k = k,
                          rho = rho,
                          method = method,
                          separation = separation,
                          KEEP.OUT.ATTRS = FALSE)

result.list <- parLapply(
  cl,
  X   = split(param.grid, seq_len(nrow(param.grid))),
  fun = simulate_unbalanced
)

result_gininobalance <- do.call(rbind, result.list)

result <- result_gininobalance
result <- result %>%
  mutate(Diff.gini = Gini.real - Gini.synt)

stopCluster(cl)

###### Separation ######
distance <- result %>%
  mutate(separation = factor(separation,
                             levels = sort(unique(separation)),
                             labels = paste0(sort(unique(separation)), "σ")))

# Diff.gini
distance.gini <- ggplot(distance, aes(x = separation, y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Diff.gini"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
distance.mean <- ggplot(distance, aes(x = separation, y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Mean.distance"
  ) +
  theme_minimal(base_size = 14)

# Specks
distance.speck <- ggplot(distance, aes(x = separation, y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Separation",
    y     = "Speck"
  ) +
  theme_minimal(base_size = 14)


###### Cluster ######
clusternum <- result %>%
  mutate(separation = factor(k,
                             levels = sort(unique(k)),
                             labels = sort(unique(k))))

# Diff.gini
clusternum.gini <- ggplot(clusternum, aes(x = factor(k), y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
clusternum.mean <- ggplot(clusternum, aes(x = factor(k), y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster"
  ) +
  theme_minimal(base_size = 14)

# Specks
clusternum.speck <- ggplot(clusternum, aes(x = factor(k), y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster",
    y     = "Speck"
  ) +
  theme_minimal(base_size = 14)


###### p ######
variable <- result %>%
  mutate(separation = factor(p,
                             levels = sort(unique(p)),
                             labels = sort(unique(p))))

# Diff.gini
variable.gini <- ggplot(variable, aes(x = factor(p), y = Diff.gini)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

# Mean.distance
variable.mean <- ggplot(variable, aes(x = factor(p), y = Mean.distance)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Variables"
  ) +
  theme_minimal(base_size = 14)

variable.speck <- ggplot(variable, aes(x = factor(p), y = Speck)) +
  geom_boxplot(fill = "#6E9FC6", outlier.size = 1) +
  labs(
    x     = "Cluster",
    y     = "Specks"
  ) +
  theme_minimal(base_size = 14)


# Summary graphic
layout <- ((distance.speck  | clusternum.speck  | variable.speck) /
            (distance.gini  | clusternum.gini  | variable.gini ) /
            (distance.mean  | clusternum.mean  | variable.mean )) + 
  plot_annotation(title = "Unbalanced clusters")

print(layout)

desired_separation <- c(0.1, 2, 6, 10)
needs_cart_refresh <- TRUE

if(exists("result_cart_250")){
  current_separation <- sort(unique(result_cart_250$separation))
  needs_cart_refresh <- !all(desired_separation %in% current_separation)
}

if(needs_cart_refresh){
  n.cores <- detectCores() - 1
  cl <- makeCluster(n.cores)
  total.m <- 1000
  
  clusterEvalQ(cl, {
    library(mvtnorm)
    library(NbClust)
    library(synthpop)
    library(clue)
    library(DescTools)
    library(factoextra)
    library(cluster)
  })
  
  clusterExport(cl,
    varlist = c("simulate_one",
                "data.generation",
                "centroid.generation",
                "synt.data.generation",
                "k.decision",
                "label.switching",
                "specks.correct",
                "total.m"),
    envir = .GlobalEnv)
  
  clusterSetRNGStream(cl, iseed = 123)
  pboptions(type = "timer")  # Enable ETA progress bar
  
  method <- c("cart")
  N <- c(250)
  p <- c(2, 5, 10)
  rho <- c(0)
  k <- c(2, 3, 4)
  separation <- desired_separation
  
  param.grid <- expand.grid(N = N,
                            p = p,
                            k = k,
                            rho = rho,
                            method = method,
                            separation = separation,
                            KEEP.OUT.ATTRS = FALSE)
  
  result.list <- pblapply(
    X   = split(param.grid, seq_len(nrow(param.grid))),
    cl  = cl,
    FUN = simulate_one
  )
  
  # Filter out NULL results from combinations that never converged within max attempts
  result.list <- Filter(Negate(is.null), result.list)
  if (!length(result.list)) {
    stop("simulate_one returned no successful results for the specified grid.")
  }
  
  result_cart_250 <- dplyr::bind_rows(result.list)
  stopCluster(cl)
}

result <- result_cart_250 %>%
  dplyr::filter(separation %in% desired_separation)


# Use the actual simulation count from total.m
total_simulations <- total.m

if(!"success_rate" %in% names(result)) {
  group_cols <- intersect(c("N", "p", "k", "rho", "method", "separation", "k.real"), names(result))
  has_count <- "count" %in% names(result)

  if(length(group_cols)) {
    result <- result %>%
      group_by(across(all_of(group_cols))) %>%
      mutate(success_rate = {
        rate <- if (has_count) {
          pmin(total_simulations / dplyr::first(count), 1)
        } else if (all(is.na(Speck))) {
          0
        } else if (total_simulations > 0) {
          dplyr::n() / total_simulations
        } else {
          NA_real_
        }
        rep(rate, dplyr::n())
      }) %>%
      ungroup()
  } else {
    # Fallback when grouping columns are unavailable; preserve row count
    result <- result %>%
      mutate(success_rate = if (has_count && total_simulations > 0) {
        pmin(total_simulations / count, 1)
      } else {
        NA_real_
      })
  }

  result_cart_250 <- result
}

# Data summary according to success rate
count.sum <- result %>%                               
  select(N, p, k, separation, success_rate) %>%
  distinct() %>%
  rename(success = success_rate)

# Compress according to k
count.sum.k <- count.sum %>% 
  pivot_wider(names_from = k,
              values_from = success,
              names_prefix = "Cluster = ") %>% 
  arrange(N, p, separation)

# Heatmap
# ... (Keep your existing data preparation code up to count.sum) ...

# Heatmap
count.plot <- count.sum %>%
  mutate(
    separation = factor(separation, levels = desired_separation),
    # Ensure p is ordered 2, 5, 10 so 2 appears at the bottom
    p = factor(p, levels = c(2, 5, 10)),
    k = factor(k, levels = c(2, 3, 4))
  ) %>%
  ggplot(aes(x = separation,
             y = p,
             fill = success)) +
  # 1. Add white borders (color = "white") to simulate the grid lines
  geom_tile(color = "white", linewidth = 0.5) +
  
  # 2. Adjust text size (size = 2.5 is closer to the target image)
  geom_text(aes(label = sprintf("%.3f", success)),
            color = "black", size = 2.5) +
  
  facet_grid(~ k, labeller = labeller(k = function(x) paste("Cluster:", x))) +
  
  # 3. Use distinct Blues palette to match the target image style
  # 'distiller' creates a nice gradient automatically from the Brewer palette
  scale_fill_distiller(
    palette = "Blues", 
    direction = 1,       # 1 for light->dark
    name  = " ",
    limits = c(0, 1),
    breaks = c(0, .25, .5, .75, 1),
    labels = scales::percent_format(accuracy = 1)
  ) +
  
  labs(x = "Separation", y = "Variables") +
  
  # 4. Theme adjustments to clean up the look
  theme_minimal(base_size = 14) + 
  theme(
    panel.grid = element_blank(),       # Remove grid lines
    panel.border = element_blank(),     # Remove panel borders
    axis.ticks = element_blank(),       # Remove axis ticks
    
    # Bold cluster titles, remove grey background box
    strip.text = element_text(face = "bold", size = 14, color = "black"),
    strip.background = element_blank(),
    
    # Axis labels styling
    axis.title = element_text(size = 16, face = "plain"),
    axis.text = element_text(color = "grey30"),
    
    # Legend styling
    legend.position = "right",
    legend.key.height = unit(1.5, "cm"), # Make the legend bar taller
    legend.text = element_text(size = 12)
  )

print(count.plot)

ggsave(
  filename = "cluster_number_matching_proportion.png",
  plot     = count.plot,
  width    = 9,     # Slightly wider to allow breathing room
  height   = 5,
  dpi      = 300
)
```


